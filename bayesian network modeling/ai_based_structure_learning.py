# -*- coding: utf-8 -*-
"""AI-based-structure-learning.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dgszOOzgqOeBcZXINOJoaz3DRgUx0h-k
"""

# @markdown Mount Google Drive
from google.colab import drive

drive.mount('/content/drive')

# @title Load Dataset
import pandas as pd

file_path = "/content/drive/My Drive/diabetes_indicators.csv"

df = pd.read_csv(file_path)
df = df.sample(frac=1, random_state=42).reset_index(drop=True)

df.head()

# @markdown Get Features
columns = df.columns

columns

# @title Discretize Continuous Variables
df['BMI'] = pd.cut(df['BMI'], bins=3, labels=[0, 1, 2])  # Low, Medium, High
df['Age'] = pd.cut(df['Age'], bins=3, labels=[0, 1, 2])  # Young, Middle, Old
df['MentHlth'] = pd.cut(df['MentHlth'], bins=2, labels=[0, 1])  # Good, Bad
df['PhysHlth'] = pd.cut(df['PhysHlth'], bins=2, labels=[0, 1])  # Good, Bad

df_selected = pd.read_csv('df_selected.csv')

df = df_selected

df.columns

"""## Use Simulated Annealing for Bayesian Network Learning"""

from pgmpy.estimators import HillClimbSearch, BicScore
import networkx as nx
import matplotlib.pyplot as plt
import random

hc = HillClimbSearch(df)

temperature = 1.0  # Start high
cooling_rate = 0.99  # Reduce over iterations
best_model_sa = None
best_score = float('-inf')

for i in range(100):
    print(f"Iteration {i+1}: Temperature = {temperature:.4f}")

    current_model = hc.estimate(scoring_method=BicScore(df))
    current_score = BicScore(df).score(current_model)

    # Accept or reject move based on Simulated Annealing logic
    if current_score > best_score or random.uniform(0, 1) < temperature:
        best_model_sa = current_model
        best_score = current_score

    # Reduce temperature (cooling)
    temperature *= cooling_rate

print("\nLearned Bayesian Network Structure (Edges):")
print(best_model_sa.edges())

"""### Save & Load Model"""

import pickle

with open("best_model_sa_2.pkl", "wb") as file:
    pickle.dump(best_model_sa, file)

import pickle

# Load the saved model
with open("best_model_sa_2.pkl", "rb") as file:
    loaded_model = pickle.load(file)

# Verify the loaded model
print("Loaded Model Structure:", loaded_model.edges())

best_model_sa = loaded_model

"""### Plot"""

# @title Plot Configurations
import networkx as nx
import matplotlib.pyplot as plt
from networkx.drawing.nx_pydot import graphviz_layout

target_node = "Diabetes_binary"

G = nx.DiGraph(best_model_sa.edges())

# Find direct connections (1st level)
first_level_nodes = set(nx.all_neighbors(G, target_node))

# Find second-level connections (indirect)
second_level_nodes = set()
for node in first_level_nodes:
    second_level_nodes.update(nx.all_neighbors(G, node))

# Remove first-level nodes from second-level set
second_level_nodes -= first_level_nodes
second_level_nodes.discard(target_node)

node_colors = {}
for node in G.nodes:
    if node == target_node:
        node_colors[node] = "lightgreen"
    elif node in first_level_nodes:
        node_colors[node] = "orange"
    elif node in second_level_nodes:
        node_colors[node] = "lightblue"
    else:
        node_colors[node] = "gray"

# Define Graphviz layout
pos = graphviz_layout(G, prog="dot")

# @title Plot found causal relations (Better View)
import matplotlib.pyplot as plt
import networkx as nx
from networkx.drawing.nx_pydot import graphviz_layout
from matplotlib.patches import FancyArrowPatch

plt.figure(figsize=(18, 12))
pos = graphviz_layout(G, prog="neato")

node_artists = nx.draw_networkx_nodes(
    G, pos,
    node_color=[node_colors[n] for n in G.nodes()],
    node_size=2000
)

edges = nx.draw_networkx_edges(G, pos, alpha=0.5, arrows=False)

for u, v, data in G.edges(data=True):
    x_start, y_start = pos[u]
    x_end, y_end = pos[v]

    dx = x_end - x_start
    dy = y_end - y_start
    length = (dx**2 + dy**2)**0.5

    dx /= length
    dy /= length

    arrow = FancyArrowPatch(
        (x_start + dx * 0.1, y_start + dy * 0.1),  # Start closer to the edge of node u
        (x_end - dx * 6.5, y_end - dy * 6.8),    # End closer to the edge of node v
        arrowstyle='-|>',
        mutation_scale=15,
        color='gray',
        lw=1,
        alpha=0.5,  # Transparency
    )
    plt.gca().add_patch(arrow)

nx.draw_networkx_labels(G, pos, font_size=8, font_weight="bold", verticalalignment="bottom")

import matplotlib.patches as mpatches
legend_labels = {
    "Diabetes (Target)": "lightgreen",
    "Direct Features": "orange",
    "Indirect Features": "lightblue",
    "Other Features": "gray"
}
legend_patches = [mpatches.Patch(color=color, label=label) for label, color in legend_labels.items()]
plt.legend(handles=legend_patches, loc="upper left", fontsize=10, title="Node Categories")

plt.title("Learned Bayesian Network using Simulated Annealing", fontsize=14)

plt.show()

"""### Plot structure after feature selection"""

# @title Plot Configurations
import networkx as nx
import matplotlib.pyplot as plt
from networkx.drawing.nx_pydot import graphviz_layout

target_node = "Diabetes_binary"

G = nx.DiGraph(best_model_sa.edges())

# Find direct connections (1st level)
first_level_nodes = set(nx.all_neighbors(G, target_node))

# Find second-level connections (indirect)
second_level_nodes = set()
for node in first_level_nodes:
    second_level_nodes.update(nx.all_neighbors(G, node))

# Remove first-level nodes from second-level set
second_level_nodes -= first_level_nodes
second_level_nodes.discard(target_node)

node_colors = {}
for node in G.nodes:
    if node == target_node:
        node_colors[node] = "lightgreen"
    elif node in first_level_nodes:
        node_colors[node] = "orange"
    elif node in second_level_nodes:
        node_colors[node] = "lightblue"
    else:
        node_colors[node] = "gray"

# Define Graphviz layout
pos = graphviz_layout(G, prog="dot")

# @title Plot found causal relations (Better View)
import matplotlib.pyplot as plt
import networkx as nx
from networkx.drawing.nx_pydot import graphviz_layout
from matplotlib.patches import FancyArrowPatch

plt.figure(figsize=(18, 12))
pos = graphviz_layout(G, prog="neato")

node_artists = nx.draw_networkx_nodes(
    G, pos,
    node_color=[node_colors[n] for n in G.nodes()],
    node_size=2000
)

edges = nx.draw_networkx_edges(G, pos, alpha=0.5, arrows=False)

for u, v, data in G.edges(data=True):
    x_start, y_start = pos[u]
    x_end, y_end = pos[v]

    dx = x_end - x_start
    dy = y_end - y_start
    length = (dx**2 + dy**2)**0.5

    dx /= length
    dy /= length

    arrow = FancyArrowPatch(
        (x_start + dx * 0.1, y_start + dy * 0.1),  # Start closer to the edge of node u
        (x_end - dx * 4.5, y_end - dy * 5.5),    # End closer to the edge of node v
        arrowstyle='-|>',
        mutation_scale=15,
        color='gray',
        lw=1,
        alpha=0.5,  # Transparency
    )
    plt.gca().add_patch(arrow)

nx.draw_networkx_labels(G, pos, font_size=8, font_weight="bold", verticalalignment="bottom")

import matplotlib.patches as mpatches
legend_labels = {
    "Diabetes (Target)": "lightgreen",
    "Direct Features": "orange",
    "Indirect Features": "lightblue",
    "Other Features": "gray"
}
legend_patches = [mpatches.Patch(color=color, label=label) for label, color in legend_labels.items()]
plt.legend(handles=legend_patches, loc="upper left", fontsize=10, title="Node Categories")

plt.title("Learned Bayesian Network using Simulated Annealing", fontsize=14)

plt.show()

"""## Na誰ve Bayes Bayesian Network"""

from pgmpy.models import BayesianNetwork
from pgmpy.estimators import MaximumLikelihoodEstimator

naive_bayes_model = BayesianNetwork([("Diabetes_binary", feature) for feature in df.columns if feature != "Diabetes_binary"])

naive_bayes_model.fit(df, estimator=MaximumLikelihoodEstimator)

print("Na誰ve Bayes Structure:", naive_bayes_model.edges())

import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.naive_bayes import GaussianNB, CategoricalNB
from sklearn.preprocessing import LabelEncoder, StandardScaler
from sklearn.metrics import accuracy_score, roc_auc_score

# Identify categorical and continuous features
categorical_features = ["Sex", "Age", "Education", "Income", "Smoker", "PhysActivity", "HighBP", "HighChol"]
continuous_features = ["BMI", "MentHlth", "PhysHlth"]

# Encode categorical features
label_encoders = {}
for col in categorical_features:
    le = LabelEncoder()
    df[col] = le.fit_transform(df[col])
    label_encoders[col] = le  # Save encoders for inverse transform if needed

# Standardize continuous features
scaler = StandardScaler()
df[continuous_features] = scaler.fit_transform(df[continuous_features])

# Define features & target
X = df.drop(columns=["Diabetes_binary"])
y = df["Diabetes_binary"]

# Split data
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Train GaussianNB for continuous data & CategoricalNB for categorical data
nb_continuous = GaussianNB()
nb_categorical = CategoricalNB()

# Fit models
nb_continuous.fit(X_train[continuous_features], y_train)
nb_categorical.fit(X_train[categorical_features], y_train)

# Predict
y_pred_continuous = nb_continuous.predict(X_test[continuous_features])
y_pred_categorical = nb_categorical.predict(X_test[categorical_features])

# Evaluate
acc_continuous = accuracy_score(y_test, y_pred_continuous)
auc_continuous = roc_auc_score(y_test, y_pred_continuous)
acc_categorical = accuracy_score(y_test, y_pred_categorical)
auc_categorical = roc_auc_score(y_test, y_pred_categorical)

print(f"GaussianNB - Accuracy: {acc_continuous:.4f}, AUC: {auc_continuous:.4f}")
print(f"CategoricalNB - Accuracy: {acc_categorical:.4f}, AUC: {auc_categorical:.4f}")

"""### Plot"""

# @title Plot Configurations
import networkx as nx
import matplotlib.pyplot as plt
from networkx.drawing.nx_pydot import graphviz_layout

target_node = "Diabetes_binary"

# G = nx.DiGraph(naive_bayes_model.edges())

# Find direct connections (1st level)
first_level_nodes = set(nx.all_neighbors(G, target_node))

# Find second-level connections (indirect)
second_level_nodes = set()
for node in first_level_nodes:
    second_level_nodes.update(nx.all_neighbors(G, node))

# Remove first-level nodes from second-level set
second_level_nodes -= first_level_nodes
second_level_nodes.discard(target_node)

node_colors = {}
for node in G.nodes:
    if node == target_node:
        node_colors[node] = "lightgreen"
    elif node in first_level_nodes:
        node_colors[node] = "orange"
    elif node in second_level_nodes:
        node_colors[node] = "lightblue"
    else:
        node_colors[node] = "gray"

# Define Graphviz layout
pos = graphviz_layout(G, prog="dot")

# @title Plot
import matplotlib.pyplot as plt
import networkx as nx
from networkx.drawing.nx_pydot import graphviz_layout
from matplotlib.patches import FancyArrowPatch

plt.figure(figsize=(18, 12))
pos = graphviz_layout(G, prog="neato")

node_artists = nx.draw_networkx_nodes(
    G, pos,
    node_color=[node_colors[n] for n in G.nodes()],
    node_size=2000
)

edges = nx.draw_networkx_edges(G, pos, alpha=0.5, arrows=False)

for u, v, data in G.edges(data=True):
    x_start, y_start = pos[u]
    x_end, y_end = pos[v]

    dx = x_end - x_start
    dy = y_end - y_start
    length = (dx**2 + dy**2)**0.5

    dx /= length
    dy /= length

    arrow = FancyArrowPatch(
        (x_start + dx * 0.1, y_start + dy * 0.1),  # Start closer to the edge of node u
        (x_end - dx * 6.5, y_end - dy * 6.8),    # End closer to the edge of node v
        arrowstyle='-|>',
        mutation_scale=15,
        color='gray',
        lw=1,
        alpha=0.5,  # Transparency
    )
    plt.gca().add_patch(arrow)

nx.draw_networkx_labels(G, pos, font_size=8, font_weight="bold", verticalalignment="bottom")

import matplotlib.patches as mpatches
legend_labels = {
    "Diabetes (Target)": "lightgreen",
    "Direct Features": "orange",
    "Indirect Features": "lightblue",
    "Other Features": "gray"
}
legend_patches = [mpatches.Patch(color=color, label=label) for label, color in legend_labels.items()]
plt.legend(handles=legend_patches, loc="upper left", fontsize=10, title="Node Categories")

plt.title("Na誰ve Bayes Bayesian Network", fontsize=14)

plt.show()

"""#### Plot structure after feature selection"""

# @title Plot Configurations
import networkx as nx
import matplotlib.pyplot as plt
from networkx.drawing.nx_pydot import graphviz_layout

target_node = "Diabetes_binary"

G = nx.DiGraph(naive_bayes_model.edges())

# Find direct connections (1st level)
first_level_nodes = set(nx.all_neighbors(G, target_node))

# Find second-level connections (indirect)
second_level_nodes = set()
for node in first_level_nodes:
    second_level_nodes.update(nx.all_neighbors(G, node))

# Remove first-level nodes from second-level set
second_level_nodes -= first_level_nodes
second_level_nodes.discard(target_node)

node_colors = {}
for node in G.nodes:
    if node == target_node:
        node_colors[node] = "lightgreen"
    elif node in first_level_nodes:
        node_colors[node] = "orange"
    elif node in second_level_nodes:
        node_colors[node] = "lightblue"
    else:
        node_colors[node] = "gray"

# Define Graphviz layout
pos = graphviz_layout(G, prog="dot")

# @title Plot
import matplotlib.pyplot as plt
import networkx as nx
from networkx.drawing.nx_pydot import graphviz_layout
from matplotlib.patches import FancyArrowPatch

plt.figure(figsize=(18, 12))
pos = graphviz_layout(G, prog="neato")

node_artists = nx.draw_networkx_nodes(
    G, pos,
    node_color=[node_colors[n] for n in G.nodes()],
    node_size=2000
)

edges = nx.draw_networkx_edges(G, pos, alpha=0.5, arrows=False)

for u, v, data in G.edges(data=True):
    x_start, y_start = pos[u]
    x_end, y_end = pos[v]

    dx = x_end - x_start
    dy = y_end - y_start
    length = (dx**2 + dy**2)**0.5

    dx /= length
    dy /= length

    arrow = FancyArrowPatch(
        (x_start + dx * 0.1, y_start + dy * 0.1),  # Start closer to the edge of node u
        (x_end - dx * 6.5, y_end - dy * 6.8),    # End closer to the edge of node v
        arrowstyle='-|>',
        mutation_scale=15,
        color='gray',
        lw=1,
        alpha=0.5,  # Transparency
    )
    plt.gca().add_patch(arrow)

nx.draw_networkx_labels(G, pos, font_size=8, font_weight="bold", verticalalignment="bottom")

import matplotlib.patches as mpatches
legend_labels = {
    "Diabetes (Target)": "lightgreen",
    "Direct Features": "orange",
    "Indirect Features": "lightblue",
    "Other Features": "gray"
}
legend_patches = [mpatches.Patch(color=color, label=label) for label, color in legend_labels.items()]
plt.legend(handles=legend_patches, loc="upper left", fontsize=10, title="Node Categories")

plt.title("Na誰ve Bayes Bayesian Network", fontsize=14)

plt.show()

"""## Hill Climbing with Different Scores

#### Before feature selection
"""

from pgmpy.estimators import HillClimbSearch, BicScore, K2Score, BDeuScore

hc = HillClimbSearch(df)

scores = {"BIC": BicScore(df), "K2": K2Score(df), "BDeu": BDeuScore(df)}

models = {}
for name, score in scores.items():
    print(f"Estimating structure using {name} scoring method...")
    models[name] = hc.estimate(scoring_method=score)
    print(f"{name} Model Edges:", models[name].edges())

"""#### After feature selection"""

from pgmpy.estimators import HillClimbSearch, BicScore, K2Score, BDeuScore

hc = HillClimbSearch(df)

scores = {"BIC": BicScore(df), "K2": K2Score(df), "BDeu": BDeuScore(df)}

models = {}
for name, score in scores.items():
    print(f"Estimating structure using {name} scoring method...")
    models[name] = hc.estimate(scoring_method=score)
    print(f"{name} Model Edges:", models[name].edges())

"""### Plot"""

models

# @title Plot Configurations for BIC
import networkx as nx
import matplotlib.pyplot as plt
from networkx.drawing.nx_pydot import graphviz_layout

target_node = "Diabetes_binary"

G = nx.DiGraph(models['BIC'].edges())

# Find direct connections (1st level)
first_level_nodes = set(nx.all_neighbors(G, target_node))

# Find second-level connections (indirect)
second_level_nodes = set()
for node in first_level_nodes:
    second_level_nodes.update(nx.all_neighbors(G, node))

# Remove first-level nodes from second-level set
second_level_nodes -= first_level_nodes
second_level_nodes.discard(target_node)

node_colors = {}
for node in G.nodes:
    if node == target_node:
        node_colors[node] = "lightgreen"
    elif node in first_level_nodes:
        node_colors[node] = "orange"
    elif node in second_level_nodes:
        node_colors[node] = "lightblue"
    else:
        node_colors[node] = "gray"

# Define Graphviz layout
pos = graphviz_layout(G, prog="dot")

# @title Plot for BIC
import matplotlib.pyplot as plt
import networkx as nx
from networkx.drawing.nx_pydot import graphviz_layout
from matplotlib.patches import FancyArrowPatch

plt.figure(figsize=(18, 12))
pos = graphviz_layout(G, prog="neato")

node_artists = nx.draw_networkx_nodes(
    G, pos,
    node_color=[node_colors[n] for n in G.nodes()],
    node_size=2000
)

edges = nx.draw_networkx_edges(G, pos, alpha=0.5, arrows=False)

for u, v, data in G.edges(data=True):
    x_start, y_start = pos[u]
    x_end, y_end = pos[v]

    dx = x_end - x_start
    dy = y_end - y_start
    length = (dx**2 + dy**2)**0.5

    dx /= length
    dy /= length

    arrow = FancyArrowPatch(
        (x_start + dx * 0.1, y_start + dy * 0.1),  # Start closer to the edge of node u
        (x_end - dx * 6.5, y_end - dy * 6.8),    # End closer to the edge of node v
        arrowstyle='-|>',
        mutation_scale=15,
        color='gray',
        lw=1,
        alpha=0.5,  # Transparency
    )
    plt.gca().add_patch(arrow)

nx.draw_networkx_labels(G, pos, font_size=8, font_weight="bold", verticalalignment="bottom")

import matplotlib.patches as mpatches
legend_labels = {
    "Diabetes (Target)": "lightgreen",
    "Direct Features": "orange",
    "Indirect Features": "lightblue",
    "Other Features": "gray"
}
legend_patches = [mpatches.Patch(color=color, label=label) for label, color in legend_labels.items()]
plt.legend(handles=legend_patches, loc="upper left", fontsize=10, title="Node Categories")

plt.title("Learned Bayesian Network using Hill Climbing (BIC)", fontsize=14)

plt.show()

# @title Plot Configurations for K2
import networkx as nx
import matplotlib.pyplot as plt
from networkx.drawing.nx_pydot import graphviz_layout

target_node = "Diabetes_binary"

G = nx.DiGraph(models['K2'].edges())

# Find direct connections (1st level)
first_level_nodes = set(nx.all_neighbors(G, target_node))

# Find second-level connections (indirect)
second_level_nodes = set()
for node in first_level_nodes:
    second_level_nodes.update(nx.all_neighbors(G, node))

# Remove first-level nodes from second-level set
second_level_nodes -= first_level_nodes
second_level_nodes.discard(target_node)

node_colors = {}
for node in G.nodes:
    if node == target_node:
        node_colors[node] = "lightgreen"
    elif node in first_level_nodes:
        node_colors[node] = "orange"
    elif node in second_level_nodes:
        node_colors[node] = "lightblue"
    else:
        node_colors[node] = "gray"

# Define Graphviz layout
pos = graphviz_layout(G, prog="dot")

# @title Plot for K2
import matplotlib.pyplot as plt
import networkx as nx
from networkx.drawing.nx_pydot import graphviz_layout
from matplotlib.patches import FancyArrowPatch

plt.figure(figsize=(18, 12))
pos = graphviz_layout(G, prog="neato")

node_artists = nx.draw_networkx_nodes(
    G, pos,
    node_color=[node_colors[n] for n in G.nodes()],
    node_size=2000
)

edges = nx.draw_networkx_edges(G, pos, alpha=0.5, arrows=False)

for u, v, data in G.edges(data=True):
    x_start, y_start = pos[u]
    x_end, y_end = pos[v]

    dx = x_end - x_start
    dy = y_end - y_start
    length = (dx**2 + dy**2)**0.5

    dx /= length
    dy /= length

    arrow = FancyArrowPatch(
        (x_start + dx * 0.1, y_start + dy * 0.1),  # Start closer to the edge of node u
        (x_end - dx * 6.5, y_end - dy * 6.8),    # End closer to the edge of node v
        arrowstyle='-|>',
        mutation_scale=15,
        color='gray',
        lw=1,
        alpha=0.5,  # Transparency
    )
    plt.gca().add_patch(arrow)

nx.draw_networkx_labels(G, pos, font_size=8, font_weight="bold", verticalalignment="bottom")

import matplotlib.patches as mpatches
legend_labels = {
    "Diabetes (Target)": "lightgreen",
    "Direct Features": "orange",
    "Indirect Features": "lightblue",
    "Other Features": "gray"
}
legend_patches = [mpatches.Patch(color=color, label=label) for label, color in legend_labels.items()]
plt.legend(handles=legend_patches, loc="upper left", fontsize=10, title="Node Categories")

plt.title("Learned Bayesian Network using Hill Climbing (K2)", fontsize=14)

plt.show()

# @title Plot Configurations for BDeu
import networkx as nx
import matplotlib.pyplot as plt
from networkx.drawing.nx_pydot import graphviz_layout

target_node = "Diabetes_binary"

G = nx.DiGraph(models['BDeu'].edges())

# Find direct connections (1st level)
first_level_nodes = set(nx.all_neighbors(G, target_node))

# Find second-level connections (indirect)
second_level_nodes = set()
for node in first_level_nodes:
    second_level_nodes.update(nx.all_neighbors(G, node))

# Remove first-level nodes from second-level set
second_level_nodes -= first_level_nodes
second_level_nodes.discard(target_node)

node_colors = {}
for node in G.nodes:
    if node == target_node:
        node_colors[node] = "lightgreen"
    elif node in first_level_nodes:
        node_colors[node] = "orange"
    elif node in second_level_nodes:
        node_colors[node] = "lightblue"
    else:
        node_colors[node] = "gray"

# Define Graphviz layout
pos = graphviz_layout(G, prog="dot")

# @title Plot for BDeu
import matplotlib.pyplot as plt
import networkx as nx
from networkx.drawing.nx_pydot import graphviz_layout
from matplotlib.patches import FancyArrowPatch

plt.figure(figsize=(18, 12))
pos = graphviz_layout(G, prog="neato")

node_artists = nx.draw_networkx_nodes(
    G, pos,
    node_color=[node_colors[n] for n in G.nodes()],
    node_size=2000
)

edges = nx.draw_networkx_edges(G, pos, alpha=0.5, arrows=False)

for u, v, data in G.edges(data=True):
    x_start, y_start = pos[u]
    x_end, y_end = pos[v]

    dx = x_end - x_start
    dy = y_end - y_start
    length = (dx**2 + dy**2)**0.5

    dx /= length
    dy /= length

    arrow = FancyArrowPatch(
        (x_start + dx * 0.1, y_start + dy * 0.1),  # Start closer to the edge of node u
        (x_end - dx * 6.5, y_end - dy * 6.8),    # End closer to the edge of node v
        arrowstyle='-|>',
        mutation_scale=15,
        color='gray',
        lw=1,
        alpha=0.5,  # Transparency
    )
    plt.gca().add_patch(arrow)

nx.draw_networkx_labels(G, pos, font_size=8, font_weight="bold", verticalalignment="bottom")

import matplotlib.patches as mpatches
legend_labels = {
    "Diabetes (Target)": "lightgreen",
    "Direct Features": "orange",
    "Indirect Features": "lightblue",
    "Other Features": "gray"
}
legend_patches = [mpatches.Patch(color=color, label=label) for label, color in legend_labels.items()]
plt.legend(handles=legend_patches, loc="upper left", fontsize=10, title="Node Categories")

plt.title("earned Bayesian Network using Hill Climbing (BDeu)", fontsize=14)

plt.show()

"""#### Plot the structures after feature selection"""

# @title Plot Configurations for BIC
import networkx as nx
import matplotlib.pyplot as plt
from networkx.drawing.nx_pydot import graphviz_layout

target_node = "Diabetes_binary"

G = nx.DiGraph(models['BIC'].edges())

# Find direct connections (1st level)
first_level_nodes = set(nx.all_neighbors(G, target_node))

# Find second-level connections (indirect)
second_level_nodes = set()
for node in first_level_nodes:
    second_level_nodes.update(nx.all_neighbors(G, node))

# Remove first-level nodes from second-level set
second_level_nodes -= first_level_nodes
second_level_nodes.discard(target_node)

node_colors = {}
for node in G.nodes:
    if node == target_node:
        node_colors[node] = "lightgreen"
    elif node in first_level_nodes:
        node_colors[node] = "orange"
    elif node in second_level_nodes:
        node_colors[node] = "lightblue"
    else:
        node_colors[node] = "gray"

# Define Graphviz layout
pos = graphviz_layout(G, prog="dot")

# @title Plot for BIC
import matplotlib.pyplot as plt
import networkx as nx
from networkx.drawing.nx_pydot import graphviz_layout
from matplotlib.patches import FancyArrowPatch

plt.figure(figsize=(18, 12))

pos = graphviz_layout(G, prog="neato")

node_artists = nx.draw_networkx_nodes(
    G, pos,
    node_color=[node_colors[n] for n in G.nodes()],
    node_size=2000
)

edges = nx.draw_networkx_edges(G, pos, alpha=0.5, arrows=False)

for u, v, data in G.edges(data=True):
    x_start, y_start = pos[u]
    x_end, y_end = pos[v]

    dx = x_end - x_start
    dy = y_end - y_start
    length = (dx**2 + dy**2)**0.5

    dx /= length
    dy /= length

    arrow = FancyArrowPatch(
        (x_start + dx * 0.1, y_start + dy * 0.1),  # Start closer to the edge of node u
        (x_end - dx * 4.5, y_end - dy * 6.8),    # End closer to the edge of node v
        arrowstyle='-|>',
        mutation_scale=15,
        color='gray',
        lw=1,
        alpha=0.5,  # Transparency
    )
    plt.gca().add_patch(arrow)

nx.draw_networkx_labels(G, pos, font_size=8, font_weight="bold", verticalalignment="bottom")

import matplotlib.patches as mpatches
legend_labels = {
    "Diabetes (Target)": "lightgreen",
    "Direct Features": "orange",
    "Indirect Features": "lightblue",
    "Other Features": "gray"
}
legend_patches = [mpatches.Patch(color=color, label=label) for label, color in legend_labels.items()]
plt.legend(handles=legend_patches, loc="upper left", fontsize=10, title="Node Categories")

plt.title("Learned Bayesian Network using Hill Climbing (BIC)", fontsize=14)

plt.show()

# @title Plot Configurations for K2
import networkx as nx
import matplotlib.pyplot as plt
from networkx.drawing.nx_pydot import graphviz_layout

target_node = "Diabetes_binary"

G = nx.DiGraph(models['K2'].edges())

# Find direct connections (1st level)
first_level_nodes = set(nx.all_neighbors(G, target_node))

# Find second-level connections (indirect)
second_level_nodes = set()
for node in first_level_nodes:
    second_level_nodes.update(nx.all_neighbors(G, node))

# Remove first-level nodes from second-level set
second_level_nodes -= first_level_nodes
second_level_nodes.discard(target_node)

node_colors = {}
for node in G.nodes:
    if node == target_node:
        node_colors[node] = "lightgreen"
    elif node in first_level_nodes:
        node_colors[node] = "orange"
    elif node in second_level_nodes:
        node_colors[node] = "lightblue"
    else:
        node_colors[node] = "gray"

# Define Graphviz layout
pos = graphviz_layout(G, prog="dot")

# @title Plot for K2
import matplotlib.pyplot as plt
import networkx as nx
from networkx.drawing.nx_pydot import graphviz_layout
from matplotlib.patches import FancyArrowPatch

plt.figure(figsize=(18, 12))
pos = graphviz_layout(G, prog="neato")

node_artists = nx.draw_networkx_nodes(
    G, pos,
    node_color=[node_colors[n] for n in G.nodes()],
    node_size=2000
)

edges = nx.draw_networkx_edges(G, pos, alpha=0.5, arrows=False)

for u, v, data in G.edges(data=True):
    x_start, y_start = pos[u]
    x_end, y_end = pos[v]

    dx = x_end - x_start
    dy = y_end - y_start
    length = (dx**2 + dy**2)**0.5

    dx /= length
    dy /= length

    arrow = FancyArrowPatch(
        (x_start + dx * 0.1, y_start + dy * 0.1),  # Start closer to the edge of node u
        (x_end - dx * 5.0, y_end - dy * 5.3),    # End closer to the edge of node v
        arrowstyle='-|>',
        mutation_scale=15,
        color='gray',
        lw=1,
        alpha=0.5,  # Transparency
    )
    plt.gca().add_patch(arrow)

nx.draw_networkx_labels(G, pos, font_size=8, font_weight="bold", verticalalignment="bottom")

import matplotlib.patches as mpatches
legend_labels = {
    "Diabetes (Target)": "lightgreen",
    "Direct Features": "orange",
    "Indirect Features": "lightblue",
    "Other Features": "gray"
}
legend_patches = [mpatches.Patch(color=color, label=label) for label, color in legend_labels.items()]
plt.legend(handles=legend_patches, loc="upper left", fontsize=10, title="Node Categories")

plt.title("Learned Bayesian Network using Hill Climbing (K2)", fontsize=14)

plt.show()

# @title Plot for K2 aftere feature selection (better view)
import networkx as nx
import matplotlib.pyplot as plt
import pygraphviz as pgv
from networkx.drawing.nx_agraph import to_agraph

# Convert NetworkX graph to PyGraphviz AGraph (forces proper arrow rendering)
A = to_agraph(G)

# Use "fdp" layout for better spacing (or "dot" for tree-like structure)
A.layout(prog="dot")

A.draw("bayesian_network_k2.png")

plt.figure(figsize=(10, 10))
img = plt.imread("bayesian_network_k2.png")
plt.imshow(img)
plt.axis("off")
plt.show()

# @title Plot Configurations for BDeu
import networkx as nx
import matplotlib.pyplot as plt
from networkx.drawing.nx_pydot import graphviz_layout

target_node = "Diabetes_binary"

G = nx.DiGraph(models['BDeu'].edges())

# Find direct connections (1st level)
first_level_nodes = set(nx.all_neighbors(G, target_node))

# Find second-level connections (indirect)
second_level_nodes = set()
for node in first_level_nodes:
    second_level_nodes.update(nx.all_neighbors(G, node))

# Remove first-level nodes from second-level set
second_level_nodes -= first_level_nodes
second_level_nodes.discard(target_node)

node_colors = {}
for node in G.nodes:
    if node == target_node:
        node_colors[node] = "lightgreen"
    elif node in first_level_nodes:
        node_colors[node] = "orange"
    elif node in second_level_nodes:
        node_colors[node] = "lightblue"
    else:
        node_colors[node] = "gray"

# Define Graphviz layout
pos = graphviz_layout(G, prog="dot")

# @title Plot for BDeu
import matplotlib.pyplot as plt
import networkx as nx
from networkx.drawing.nx_pydot import graphviz_layout
from matplotlib.patches import FancyArrowPatch

plt.figure(figsize=(18, 12))
pos = graphviz_layout(G, prog="neato")

node_artists = nx.draw_networkx_nodes(
    G, pos,
    node_color=[node_colors[n] for n in G.nodes()],
    node_size=2000
)

edges = nx.draw_networkx_edges(G, pos, alpha=0.5, arrows=False)

for u, v, data in G.edges(data=True):
    x_start, y_start = pos[u]
    x_end, y_end = pos[v]

    dx = x_end - x_start
    dy = y_end - y_start
    length = (dx**2 + dy**2)**0.5

    dx /= length
    dy /= length

    arrow = FancyArrowPatch(
        (x_start + dx * 0.1, y_start + dy * 0.1),  # Start closer to the edge of node u
        (x_end - dx * 4.5, y_end - dy * 4.8),    # End closer to the edge of node v
        arrowstyle='-|>',
        mutation_scale=15,
        color='gray',
        lw=1,
        alpha=0.5,  # Transparency
    )
    plt.gca().add_patch(arrow)

nx.draw_networkx_labels(G, pos, font_size=8, font_weight="bold", verticalalignment="bottom")

import matplotlib.patches as mpatches
legend_labels = {
    "Diabetes (Target)": "lightgreen",
    "Direct Features": "orange",
    "Indirect Features": "lightblue",
    "Other Features": "gray"
}
legend_patches = [mpatches.Patch(color=color, label=label) for label, color in legend_labels.items()]
plt.legend(handles=legend_patches, loc="upper left", fontsize=10, title="Node Categories")

plt.title("earned Bayesian Network using Hill Climbing (BDeu)", fontsize=14)

plt.show()